diff a/os/src/main.rs b/os/src/main.rs	(rejected hunks)
@@ -4,6 +4,7 @@
 //! important ones are:
 //!
 //! - [`trap`]: Handles all cases of switching from userspace to the kernel
+//! - [`task`]: Task management
 //! - [`syscall`]: System call handling and implementation
 //!
 //! The operating system also starts in this module. Kernel code starts
@@ -11,34 +12,34 @@
 //! initialize various pieces of functionality. (See its source code for
 //! details.)
 //!
-//! We then call [`batch::run_next_app()`] and for the first time go to
+//! We then call [`task::run_first_task()`] and for the first time go to
 //! userspace.
 
 #![deny(missing_docs)]
 #![deny(warnings)]
-#![allow(unused)]
 #![no_std]
 #![no_main]
 #![feature(panic_info_message)]
 
-use core::arch::{global_asm, asm};
-
-use crate::console::print;
+use core::arch::global_asm;
 
 #[path = "boards/qemu.rs"]
 mod board;
 
 #[macro_use]
 mod console;
-pub mod batch;
+mod config;
 mod lang_items;
+mod loader;
 mod sbi;
 mod sync;
 pub mod syscall;
+pub mod task;
+mod timer;
 pub mod trap;
 
-global_asm!(include_str!("entry.asm"));     // 0x80200000
-global_asm!(include_str!("link_app.S"));    // 0x80400000
+global_asm!(include_str!("entry.asm"));
+global_asm!(include_str!("link_app.S"));
 
 /// clear BSS segment
 fn clear_bss() {
@@ -50,49 +51,17 @@ fn clear_bss() {
         core::slice::from_raw_parts_mut(sbss as usize as *mut u8, ebss as usize - sbss as usize)
             .fill(0);
     }
-/*  another implementation:
-    (sbss as usize..ebss as usize).for_each(
-        |a| unsafe { (a as *mut u8).write_volatile(0); }
-    );
-*/
-}
-
-fn welcome() {
-    // here we are "cheating" the compiler. We ask it to help us find functions.
-    // While in fact we treated these "functions" as values
-    extern "C" {
-        fn stext();     // start addr of text segment
-        fn etext();     // end addr of text segment
-        fn srodata();   // start addr of Read-Only data segment
-        fn erodata();   // end addr of Read-Only data ssegment
-        fn sdata();     // start addr of data segment
-        fn edata();     // end addr of data segment
-        fn sbss();      // start addr of BSS segment
-        fn ebss();      // end addr of BSS segment
-        fn boot_stack_lower_bound(); // stack lower bound
-        fn boot_stack_top(); // stack top
-        fn logo();
-    }
-    info!("memory layout:");
-    info!("rust-sbi  [0x80000000, 0x80200000)");
-    info!(".text     [{:#x}, {:#x})", stext as usize, etext as usize);
-    info!(".rodata   [{:#x}, {:#x})", srodata as usize, erodata as usize);
-    info!(".data     [{:#x}, {:#x})", sdata as usize, edata as usize);
-    info!(".stack    [{:#x}, {:#x})",
-        boot_stack_lower_bound as usize, boot_stack_top as usize);
-    info!(".bss      [{:#x}, {:#x})", sbss as usize, ebss as usize);
-    debug!("ðŸ˜„Hello worldðŸ˜„");
-
-
 }
 
-/// the rust entry-point of os. 0x80200000
+/// the rust entry-point of os
 #[no_mangle]
 pub fn rust_main() -> ! {
     clear_bss();
-//    (0..110).for_each(|n| { print!("\x1b[{}m {} \x1b[0m ", n, n);});
-    welcome();
-    trap::init();           // set up stvec
-    batch::init();          // in fact just print some infomation about app
-    batch::run_next_app();
+    println!("[kernel] Hello, world!");
+    trap::init();
+    loader::load_apps();
+    trap::enable_timer_interrupt();
+    timer::set_next_trigger();
+    task::run_first_task();
+    panic!("Unreachable in rust_main!");
 }
