diff a/os/src/task/mod.rs b/os/src/task/mod.rs	(rejected hunks)
@@ -14,12 +14,15 @@ mod switch;
 #[allow(clippy::module_inception)]
 mod task;
 
+use crate::mm::vmprint;
+use crate::timer::{get_time_ms, get_ucnt, get_kcnt};
 use crate::loader::{get_app_data, get_num_app};
 use crate::sync::UPSafeCell;
 use crate::trap::TrapContext;
+use crate::mm::PageTable;
 use alloc::vec::Vec;
 use lazy_static::*;
-use switch::__switch;
+pub use switch::__switch;
 use task::{TaskControlBlock, TaskStatus};
 
 pub use context::TaskContext;
@@ -37,25 +40,29 @@ pub struct TaskManager {
     /// total number of tasks
     num_app: usize,
     /// use inner value to get mutable access
-    inner: UPSafeCell<TaskManagerInner>,
+    pub inner: UPSafeCell<TaskManagerInner>,
 }
 
 /// The task manager inner in 'UPSafeCell'
-struct TaskManagerInner {
+pub struct TaskManagerInner {
     /// task list
-    tasks: Vec<TaskControlBlock>,
+    pub tasks: Vec<TaskControlBlock>,
     /// id of current `Running` task
     current_task: usize,
 }
 
+//pub fn get_tcb_vec() -> &mut
+
 lazy_static! {
     /// a `TaskManager` global instance through lazy_static!
+    /// read data into task from elf file
     pub static ref TASK_MANAGER: TaskManager = {
-        println!("init TASK_MANAGER");
+        info!(" init TASK_MANAGER");
         let num_app = get_num_app();
-        println!("num_app = {}", num_app);
+        info!(" num_app = {}", num_app);
         let mut tasks: Vec<TaskControlBlock> = Vec::new();
         for i in 0..num_app {
+            // 
             tasks.push(TaskControlBlock::new(get_app_data(i), i));
         }
         TaskManager {
@@ -70,6 +77,30 @@ lazy_static! {
     };
 }
 
+/// get current taskid. mostly used one
+pub fn get_current_taskid() -> usize {
+    TASK_MANAGER.inner.exclusive_access().current_task
+}
+/// get the specified task's info
+pub fn get_taskinfo(id: usize) -> TaskInfo {
+    TaskInfo {
+        id,
+        status: TASK_MANAGER.inner.exclusive_access().tasks[id].task_status,
+        times: (get_ucnt(id), get_kcnt(id)),
+    }
+}
+
+#[allow(missing_docs)]
+#[derive(Debug)]
+pub struct TaskInfo {
+    pub id: usize,
+    pub status: TaskStatus,
+    /// 0 for kernel, 1 for user
+    pub times: (usize, usize),
+    //pub root_pagetable: usize,
+    //pub size: usize,
+}
+
 impl TaskManager {
     /// Run the first task in task list.
     ///
@@ -77,14 +108,17 @@ impl TaskManager {
     /// But in ch4, we load apps statically, so the first task is a real app.
     fn run_first_task(&self) -> ! {
         let mut inner = self.inner.exclusive_access();
-        let next_task = &mut inner.tasks[0];
-        next_task.task_status = TaskStatus::Running;
-        let next_task_cx_ptr = &next_task.task_cx as *const TaskContext;
-        drop(inner);
+        let first_task = &mut inner.tasks[0];
+        first_task.task_status = TaskStatus::Running;
+        let first_task_cx_ptr = &first_task.task_cx as *const TaskContext;
         let mut _unused = TaskContext::zero_init();
+        unsafe{
+            crate::syscall::LAST_ENTERING_TIME = get_time_ms();
+        }
         // before this, we should drop local variables that must be dropped manually
+        drop(inner);
         unsafe {
-            __switch(&mut _unused as *mut _, next_task_cx_ptr);
+            __switch(&mut _unused as *mut _, first_task_cx_ptr);
         }
         panic!("unreachable in run_first_task!");
     }
@@ -131,6 +165,7 @@ impl TaskManager {
     fn run_next_task(&self) {
         if let Some(next) = self.find_next_task() {
             let mut inner = self.inner.exclusive_access();
+            //debug!("next task is {}", next);
             let current = inner.current_task;
             inner.tasks[next].task_status = TaskStatus::Running;
             inner.current_task = next;
@@ -143,15 +178,35 @@ impl TaskManager {
             }
             // go back to user mode
         } else {
-            println!("All applications completed!");
+            statistic();
             use crate::board::QEMUExit;
             crate::board::QEMU_EXIT_HANDLE.exit_success();
         }
     }
 }
 
+fn statistic() {
+    let n = get_num_app();
+    let total_cnt_k: usize= (0..n).map(|i| get_kcnt(i)).sum();
+    let total_cnt_u: usize= (0..n).map(|i| get_ucnt(i)).sum();
+    println!("");
+    debug!("All applications completed!");
+    (0..n).for_each(|id| {
+        trace!(" {:?}", get_taskinfo(id));
+    });
+    debug!("total running time: {}ms(user), {}ms(kernel)", total_cnt_u, total_cnt_k);
+}
+
 /// Run the first task in task list.
 pub fn run_first_task() {
+    // try to print first app's pagetable
+    let inner = TASK_MANAGER.inner.exclusive_access();
+    let token = inner.tasks[0].get_user_token();
+    let pgtbl = PageTable::from_token(token);
+    info!(" first task's pagetable");
+    vmprint(&pgtbl);
+    // don't forget to drop inner
+    drop(inner);
     TASK_MANAGER.run_first_task();
 }
 
@@ -191,4 +246,4 @@ pub fn current_user_token() -> usize {
 /// Get the current 'Running' task's trap contexts.
 pub fn current_trap_cx() -> &'static mut TrapContext {
     TASK_MANAGER.get_current_trap_cx()
-}
+}
\ No newline at end of file
