diff a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rs	(rejected hunks)
@@ -30,10 +46,21 @@ lazy_static! {
     pub static ref KERNEL_SPACE: Arc<UPSafeCell<MemorySet>> =
         Arc::new(unsafe { UPSafeCell::new(MemorySet::new_kernel()) });
 }
-/// memory set structure, controls virtual-memory space
+/// high-level structure, controls all the `virtual-memory space` of an app(or kernel).
+/// a `set`(collection) is consisted of many `areas`.
+/// 注意`PageTable`下挂着所有多级页表的节点所在的物理页帧，
+/// 而每个`MapArea`下则挂着对应逻辑段中的数据所在的物理页帧，
+/// 这两部分合在一起构成了一个地址空间所需的所有物理页帧
+/// note: memory_set is a higher level abstraction than pagetable.
+/// since pagetable is not so easy to deal with. with the help of 
+/// memory_set now, we are luckily that we don't need to deal with
+/// pagetable all the time. we just build app's memory_set, 
+/// and its pagetable will be built along the process
 pub struct MemorySet {
-    page_table: PageTable,
-    areas: Vec<MapArea>,
+    ///
+    pub page_table: PageTable,
+    /// 描述`一段连续地址的虚拟内存`(逻辑段),
+    pub areas: Vec<MapArea>,
 }
 
 impl MemorySet {
@@ -294,6 +336,7 @@ impl MapArea {
             map_perm,
         }
     }
+    /// return a same copy of MapArea
     pub fn from_another(another: &Self) -> Self {
         Self {
             vpn_range: VPNRange::new(another.vpn_range.get_start(), another.vpn_range.get_end()),
