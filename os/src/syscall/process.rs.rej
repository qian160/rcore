diff a/os/src/syscall/process.rs b/os/src/syscall/process.rs	(rejected hunks)
@@ -39,6 +45,24 @@ pub fn sys_fork() -> isize {
     new_pid as isize
 }
 
+pub fn sys_spawn(path: *const u8) -> isize {
+    let str = translated_str(current_user_token(), path);
+    debug!(" str = {}", str);
+    let current_task = current_task().unwrap();
+    let new_task = current_task.spawn(&get_app_data_by_name(&str).unwrap());
+    let new_pid = new_task.pid.0;
+    // modify trap context of new_task, because it returns immediately after switching
+    let trap_cx = new_task.inner_exclusive_access().get_trap_cx();
+    // we do not have to move to next instruction since we have done it before
+    // for child process, fork returns 0
+    trap_cx.x[10] = new_pid;
+    // add new task to scheduler
+    add_task(new_task);
+    new_pid as isize
+}
+/// 功能：将当前进程的地址空间清空并加载一个特定的可执行文件，返回用户态后开始它的执行。
+/// 参数：path 给出了要加载的可执行文件的名字；
+/// 返回值：如果出错的话（如找不到名字相符的可执行文件）则返回 -1，否则不应该返回。
 pub fn sys_exec(path: *const u8) -> isize {
     let token = current_user_token();
     let path = translated_str(token, path);
@@ -50,9 +74,10 @@ pub fn sys_exec(path: *const u8) -> isize {
         -1
     }
 }
-
-/// If there is not a child process whose pid is same as given, return -1.
-/// Else if there is a child process but it is still running, return -2.
+/// return value:
+/// -1: pid not exists
+/// -2: the target process is not exited yet
+/// other case returns that process's pid
 pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize {
     let task = current_task().unwrap();
     // find a child process
